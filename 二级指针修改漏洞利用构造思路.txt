函数1：
1》声明0x10_chunk，偏移1放置9999；
2》在数组2020a0[qword_202098*8]存储8个字符，并把对应的地址记录在chunk的偏移0处；
3》最后把chunk的地址记录在202140；

0x10_chunk[1]=9999；
2020a0[qword_202098*8]存储8个字符，0x10_chunk[0]=&2020a0[qword_202098*8]；
#即0x10_chunk[0]存放的指针，指针上内容可自修改
202140：0x10_chunk(其上存放8个字节的地址)
#202140[qword_202098*8]=&0x10_chunk







函数2：add
1》qword_202090<=0x13;货物清单
2》qword_2021e0[v2]记录0x10_chunk的地址，0x10_chunk[0]记录货物名字的地址，0x10_chunk[1]记录&stru_3d8+15
未发现漏洞
del:
1》free 货物名字chunk，free存放货物名字chunk地址的chunk；
2》存放货物名字chunk地址的chunk的地址被清零。
未发现漏洞
edit：
1》2021e0[v2]记录0x10_chunk的地址;
#2021e0[v2]=&0x10_chunk
2》0x10_chunk[0]记录货物名字的地址；
#0x10_chunk[0]上是货物名字，可修改

利用思路：

第一步：
已知条件：
功能1真修改中，可修改数组2020a0的内容（数组2020a0的地址放在0x10_chunk处，0x10_chunk地址放在全局数组1处，利用全局数组1修改）；
#即修改的是二级指针
功能2真修改中，可修改二级分配的chunk内容（二级chunk地址放在0x10_chunk处，0x10_chunk地址放在全局数组2处，利用全局数组2修改）；

总结：由于功能2存在溢出，且修改的本质是同种修改，所以可以修改数组2020a0的内容。
利用：可修改数组2020a0的内容为数组2020a0的相邻地址处，并把相邻地址处内容修改为put_got表的地址。这样就人为构造了一个本质相同的修改，进而可以利用功能2的溢出进行修改put_got的内容了。