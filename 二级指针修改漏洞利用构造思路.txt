函数1：
1》声明0x10_chunk，偏移1放置9999；
2》在数组2020a0[qword_202098*8]存储8个字符，并把对应的地址记录在chunk的偏移0处；
3》最后把chunk的地址记录在202140；

0x10_chunk[1]=9999；
2020a0[qword_202098*8]存储8个自定义字符，0x10_chunk[0]=&2020a0[qword_202098*8]；
202140：0x10_chunk的地址
##即数组202140存放0x10_chunk的地址，该0x10地址上又存放2020a0[qword_202098*8]的地址。






函数2：add
1》qword_202090<=0x13;货物清单
2》qword_2021e0[v2]记录0x10_chunk的地址，0x10_chunk[0]记录货物名字的地址，0x10_chunk[1]记录&stru_3d8+15
未发现漏洞
del:
1》free 货物名字chunk，free存放货物名字chunk地址的chunk，即add中最开始malloc的那个0x10_chunk；
2》存放货物名字chunk地址的chunk的地址被清零,即add中最开始malloc的那个0x10_chunk被清零。//存放货物名字的地址自然不会存在了。
未发现漏洞
##即先free 数组2021e0上值上的值，再free数组2021e0上的值。
#其实这里也有索引溢出，只是没有大的内容溢出来构造伪造chunk，即UAF不可用了。


edit：
1》edit printf：
%s 地址*2021e0[v2]，即货物名字的地址，即可printf货物名字地址上的值
2》然后 read 地址*2021e0[v2]，即货物名字的地址，即可重写货物名字。
这里有overflow。

利用思路：

第一步：
已知条件：
功能1真修改中，可修改数组2020a0的内容（数组2020a0的地址放在0x10_chunk处，0x10_chunk地址放在全局数组1 202140处，利用全局数组1修改）；
#即修改的是二级指针
功能2真修改中，可修改二级分配的chunk内容（二级chunk地址放在0x10_chunk处，0x10_chunk地址放在全局数组2  2021e0处，利用全局数组2修改）；

总结：由于功能2存在溢出，且修改的本质是同种修改，所以可以修改数组2020a0的内容。
利用：可修改数组2020a0的内容为数组2020a0的相邻地址处，并把相邻地址处内容修改为put_got表的地址。这样就人为构造了一个本质相同的修改，进而可以利用功能2的溢出进行修改put_got的内容了。

这里利用全局数组1构造edit中的二级指针修改，是因为全局数组1中存在8个字节的写。
